@import: ./coins.satyh/coins-report

document(|
  author = {中野 将生};
  department = {情報科};
  faculty = {情報};
  id = 2013553;
  title = {関数プログラミング 2-4,2-5};
|) '<

  +section ?* ?* ?:((2,3)) {課題2-4} <
    +subsection{テスト} <
      +code(```
      # eval2 (IntLit 1);;
      - : value_t = IntVal 1
      # eval2 (IntLit 11);;
      - : value_t = IntVal 11
      # eval2 (Plus (IntLit 1, Plus (IntLit 2, IntLit 11)));;
      - : value_t = IntVal 14
      # eval2 (Times (IntLit 1, Plus (IntLit 2, IntLit 11)));;
      - : value_t = IntVal 13
      # eval2 (If (Eq(IntLit 2, IntLit 11),
        Times(IntLit 1, IntLit 2),
        Times(IntLit 1, Plus(IntLit 2,IntLit 3))));;
      - : value_t = IntVal 5
      # eval2 (Eq (IntLit 1, IntLit 1));;
      - : value_t = BoolVal true
      # eval2 (Eq (IntLit 1, IntLit 2));;
      - : value_t = BoolVal false
      # eval2 (Eq (BoolLit true, BoolLit true));;
      - : value_t = BoolVal true
      # eval2 (Eq (BoolLit true, BoolLit false));;
      - : value_t = BoolVal false
      ```);
    >
    +subsection{エラ―例} <
      +code(```
      # eval2 (Plus (IntLit 1, BoolLit true));;
      Exception: Failure "interger values expected".
      # eval2 (Div (BoolLit false, IntVal 0));;
      Exception: Failure "interger values expected".
      # eval2 (Div (IntLit 1, IntVal 0));;
      Exception: Failure "divided by 0".
      ```);
    >
    +subsection{整数値と真偽値の比較} <
      +p{
        下記のようになる。
      }
      +code(```
      # eval2 (Eq (IntLit 1, BoolLit true));;
      Exception: Failure "wrong value".
      # eval2 (Eq (BoolLit true, IntLit 1));;
      Exception: Failure "wrong value".
      ```);
    >
    +subsection{Greaterの追加} <
      +p{
        全ての実装は本レポート末尾記載のソースコードか、添付したソースコードファイルを参照。
        以下に該当部分を抜粋
      }
      +code(```
        | Greater of exp_t * exp_t
      ```);
      +code(```
        | Greater (lhr, rhr) -> begin match (eval2 lhr, eval2 rhr) with
            | (IntVal lhr, IntVal rhr) -> BoolVal(lhr > rhr)
            | _ -> failwith "integer value expected"
        end
      ```);
      +code(```
      # eval2 (Greater (IntLit 5, IntLit 1));;
      - : value_t = BoolVal true
      # eval2 (Greater (IntLit 5, IntLit 5));;
      - : value_t = BoolVal false
      # eval2 (Greater (IntLit 5, IntLit 6));;
      - : value_t = BoolVal false
      ```);
    >
  >
  +section{課題2-5} <
    +subsection{binopのスコープの確認}<
      +p{
        以下のようになり参照出来ない。
      }
      +code(```
      utop # binop;;
      Line 1, characters 0-5:
      Error: Unbound value binop
      ```);
    >
    +subsection{外から使えない事の利点の考察}<
      +p{
        内部実装に使っている関数が外から見えることは好ましくない。
        そのモジュールを第三者や、暫く先の自分が使う場合に混乱を招くもととなる。
        また、スコープが狭い範囲閉じていることで、
        上書きされることを気にせずに既存既存の関数と被るような名前の関数を作ることが出来る。
      }
    >
    +subsection{eval2bへの修正}<
      +p{
        詳細な実装は本レポート末尾記載のソースコードか、添付したソースコードファイルを参照。
        私の実装では`Less`、`And`、`Or`の二項演算子を定義していることから、
        `(int -> int -> int) -> exp_t -> exp_t -> value_t`を持つ`binop_ii`と、
        `(int -> int -> bool) -> exp_t -> exp_t -> value_t`を持つ`binop_ib`、
        `(bool -> bool -> bool) -> exp_t -> exp_t -> value_t`を持つ`binop_bb`を定義した。
      }
    >
    +subsection{型の確認}<
      +p{
        REPLにて`binop`を定義したところ
        `val binop : (int -> int -> int) -> exp_t -> exp_t -> value_t = <fun>`と表示された。
        `int`と`int`を取り`int`を返すカリー化された関数を第一引数に、
        第二、第三引数に`exp_t`を取り、`value_t`を返す関数である。
      }
    >
  >
  +appendix{ソースコード}<
    +code(```
    type exp_t =
        | IntLit of int
        | Plus of exp_t * exp_t
        | Times of exp_t * exp_t
        | BoolLit of bool
        | If of exp_t * exp_t * exp_t
        | Eq of exp_t * exp_t
        | Greater of exp_t * exp_t
        (* 課題外 *)
        | And of exp_t * exp_t
        | Or of exp_t * exp_t
        | Sub of exp_t * exp_t
        | Div of exp_t * exp_t
        | Not of exp_t
        | Less of exp_t * exp_t

    type value_t =
        | IntVal of int
        | BoolVal of bool

    let rec eval2 =
        function
        | IntLit n -> IntVal n
        | BoolLit b -> BoolVal b
        | Plus (lhr, rhr) -> begin match (eval2 lhr, eval2 rhr) with
            | (IntVal lhr, IntVal rhr) -> IntVal(lhr + rhr)
            | _ -> failwith "integer value expected"
        end
        | Sub (lhr, rhr) -> begin match (eval2 lhr, eval2 rhr) with
            | (IntVal lhr, IntVal rhr) -> IntVal(lhr + rhr)
            | _ -> failwith "integer value expected"
        end
        | Times (lhr, rhr) -> begin match (eval2 lhr, eval2 rhr) with
            | (IntVal lhr, IntVal rhr) -> IntVal(lhr * rhr)
            | _ -> failwith "integer value expected"
        end
        | Div (lhr, rhr) -> begin match (eval2 lhr, eval2 rhr) with
            (* 分母が0の場合をパターンマッチで先に除外 *)
            | (IntVal _, IntVal 0) -> failwith "divided by 0"
            | (IntVal lhr, IntVal rhr) -> IntVal(lhr / rhr)
            | _ -> failwith "integer value expected"
        end
        | Greater (lhr, rhr) -> begin match (eval2 lhr, eval2 rhr) with
            | (IntVal lhr, IntVal rhr) -> BoolVal(lhr > rhr)
            | _ -> failwith "integer value expected"
        end
        | Less (lhr, rhr) -> begin match (eval2 lhr, eval2 rhr) with
            | (IntVal lhr, IntVal rhr) -> BoolVal(lhr < rhr)
            | _ -> failwith "integer value expected"
        end
        | And (lhr, rhr) -> begin match (eval2 lhr, eval2 rhr) with
            | (BoolVal lhr, BoolVal rhr) -> BoolVal(lhr && rhr)
            | _ -> failwith "integer value expected"
        end
        | Or (lhr, rhr) -> begin match (eval2 lhr, eval2 rhr) with
            | (BoolVal lhr, BoolVal rhr) -> BoolVal(lhr || rhr)
            | _ -> failwith "integer value expected"
        end
        | Not e -> begin match eval2 e with
            | BoolVal b -> BoolVal (not b)
            | _ -> failwith "boolean type expected"
        end
        | Eq(lhr, rhr) -> begin match (eval2 lhr, eval2 rhr) with
            | (IntVal lhr, IntVal rhr) -> BoolVal (lhr = rhr)
            | (BoolVal lhr, BoolVal rhr) -> BoolVal (lhr = rhr)
            | _ -> failwith "integer type expected"
        end
        | If (cond, e1, e2) -> begin match eval2 cond with
            | BoolVal true -> eval2 e1
            | BoolVal false -> eval2 e2
            | _ -> failwith "boolean type expected"
        end

    let rec eval2b =
        (* Plus, Times, Sub向け *)
        let binop_ii f lhr rhr = match (eval2b lhr, eval2b rhr) with
            | (IntVal lhr, IntVal rhr) -> IntVal (f lhr rhr)
            | _ -> failwith "integer type expected"
        in
        (* Less, Greater向け *)
        let binop_ib f lhr rhr = match (eval2b lhr, eval2b rhr) with
            | (IntVal lhr, IntVal rhr) -> BoolVal (f lhr rhr)
            | _ -> failwith "integer type expected"
        in
        (* And, Or向け *)
        let binop_bb f lhr rhr = match (eval2b lhr, eval2b rhr) with
            | (BoolVal lhr, BoolVal rhr) -> BoolVal (f lhr rhr)
            | _ -> failwith "boolean type expected"
        in
        function
        | IntLit n -> IntVal n
        | BoolLit b -> BoolVal b
        | Plus (lhr, rhr) -> binop_ii (+) lhr rhr
        | Sub (lhr, rhr) -> binop_ii (-) lhr rhr
        | Times (lhr, rhr) -> binop_ii ( * ) lhr rhr
        (* Divは分母が0の場合の処理を入れる必要があるので使えない *)
        | Div (lhr, rhr) -> begin match (eval2 lhr, eval2 rhr) with
            | (IntVal _, IntVal 0) -> failwith "divided by 0"
            | (IntVal lhr, IntVal rhr) -> IntVal(lhr / rhr)
            | _ -> failwith "integer value expected"
        end
        | Greater (lhr, rhr) -> binop_ib (>) lhr rhr
        | Less (lhr, rhr) -> binop_ib (<) lhr rhr
        | And (lhr, rhr) -> binop_bb (&&) lhr rhr
        | Or (lhr, rhr) -> binop_bb (||) lhr rhr
        | Not e -> begin match eval2b e with
            | BoolVal b -> BoolVal (not b)
            | _ -> failwith "boolean type expected"
        end
        (* Eqはint、bool両方を受けるので使えない *)
        | Eq(lhr, rhr) -> begin match (eval2b lhr, eval2b rhr) with
            | (IntVal lhr, IntVal rhr) -> BoolVal (lhr = rhr)
            | (BoolVal lhr, BoolVal rhr) -> BoolVal (lhr = rhr)
            | _ -> failwith "integer type expected"
        end
        | If (cond, e1, e2) -> begin match eval2b cond with
            | BoolVal true -> eval2b e1
            | BoolVal false -> eval2b e2
            | _ -> failwith "boolean type expected"
        end
    ```);
  >
>
