@import: ./coins.satyh/coins-report
@require: enumitem/enumitem

document(|
  author = {中野 将生};
  department = {情報科};
  faculty = {情報};
  id = 2013553;
  title = {関数プログラミング 7-2,7-3};
  en = false;
|) '<
  +section ?* ?* ?:((7,2)) {静的束縛と動的束縛} <
    +subsection { 型検査の動作の確認} <
      +p{
        `if`において`then`節の型と`else`節の型が食い違った際にエラーとなっている。
      }
      +code(```
        # S8.K7top.typecheck_string "if true then 1 else 2";;
        - : S8.K7ast.ty_t = S8.K7ast.TInt
        # S8.K7top.typecheck_string "1+2*3";;
        - : S8.K7ast.ty_t = S8.K7ast.TInt
        # S8.K7top.typecheck_string "true || false";;
        - : S8.K7ast.ty_t = S8.K7ast.TBool
        # S8.K7top.typecheck_string "if true then 1 else true";;
        Exception: (Failure "type of then and typeof else are unmatched")
        Called from unknown location
        # S8.K7top.typecheck_string "if true then false else true";;
        - : S8.K7ast.ty_t = S8.K7ast.TBool
      ```);
    >
    +subsection { 型検査の拡張 } <
      +p{
      }
      +code(```
        # S8.K7top.typecheck_string "false = 1";;
        Exception: (Failure "type error in Eq")
        Called from unknown location
        # S8.K7top.typecheck_string "1 = true";;
        Exception: (Failure "type error in Eq")
        Called from unknown location
        # S8.K7top.typecheck_string "1 = 1";;
        - : S8.K7ast.ty_t = S8.K7ast.TBool
        # S8.K7top.typecheck_string "true = false";;
        - : S8.K7ast.ty_t = S8.K7ast.TBool
        # S8.K7top.typecheck_string "1 > 2";;
        - : S8.K7ast.ty_t = S8.K7ast.TBool
        # S8.K7top.typecheck_string "1 <> 2";;
        - : S8.K7ast.ty_t = S8.K7ast.TBool
        # S8.K7top.typecheck_string "1 <> true";;
        Exception: (Failure "type error in Neq")
        Called from unknown location
      ```);
    >
  >
  +section {変数の型付けを含む型検査} <
    +p{
      7-3-1,7-3-2の解答を示す。
      `if x then x else 100`は`x`がどのような型であれ型エラーとなる。
    }
    +code(```
      # tcheck [("x", TInt); ("y", TInt)] @@ parse_repl_string "if true then x else 100";;
      - : ty_t = TInt
      # tcheck [("x", TBool); ("y", TInt)] @@ parse_repl_string "if true then x else 100";;
      Exception: (Failure "type of then and typeof else are unmatched")
      Called from unknown location
      # tcheck [("z", TInt); ("y", TInt)] @@ parse_repl_string "if true then x else 100";;
      Exception: (Failure "unbound variable: x")
      Called from unknown location
      Called from unknown location
      # tcheck [("x", TInt)] @@ parse_repl_string "if x then x else 100";;
      Exception: (Failure "if condition only take boolean type")
      Called from unknown location
      # tcheck [("x", TBool)] @@ parse_repl_string "if x then x else 100";;
      Exception: (Failure "type of then and typeof else are unmatched")
      Called from unknown location
    ```);
    +p{
      また`let`を用いて型環境を拡張できるようにした。
    }
    +code(```
      # typecheck_string "let x = true in let y = 1 in if x then y else 100";;
      - : S8.K7ast.ty_t = S8.K7ast.TInt
    ```);
  >
  +section{以降の必須課題} <
    +subsection {} <
      +p{
        これ以降は最終課題の実装に含まれているので、その結果を示す。
        `'n`表記は多相型を表す。
      }
      +code(```
      let x = 10
      let f = (fun x -> if true then x else 100)
      ```);
      +code(```
      (Typing.Let ([((Typing.PVar ((Types.Vid 16), Int)), (Typing.Int 10))],
         (Typing.Let (
            [((Typing.PVar ((Types.Vid 17), (Int -> Int))),
              (Typing.Fun ([((Types.Vid 18), Int)],
                 (Typing.If ((Typing.Bool true), (Typing.Var (Types.Vid 18)),
                    (Typing.Int 100))),
                 Int, "_f_1", ("test.ml", 2, 19, 30))))
              ],
            Typing.Never, true)),
         true))
      ```);
      +p{
        最初の`Let`は`let x = 10`のものである。
        `x`が`fun`の引数でシャドウイングされているので
        外側の環境は関係なくなっている。
        関数の式は正しく`int -> int`に推論されている。
      }
      +code(```
      let x = true
      let f = (fun x -> if true then x else 100)
      ```);
      +code(```
      (Typing.Let ([((Typing.PVar ((Types.Vid 16), Bool)), (Typing.Bool true))],
         (Typing.Let (
            [((Typing.PVar ((Types.Vid 17), (Int -> Int))),
              (Typing.Fun ([((Types.Vid 18), Int)],
                 (Typing.If ((Typing.Bool true), (Typing.Var (Types.Vid 18)),
                    (Typing.Int 100))),
                 Int, "_f_1", ("test.ml", 2, 19, 32))))
              ],
            Typing.Never, true)),
         true))
      ```);
      +p{
        同様にshadowingされている。
        これも同様に`int -> int`に推論されている。
      }
      +code(```
      let x = 43
      let y = 57
      let f = ((fun x -> if true then x else 100) (if true then y else 200))
      ```);
      +code(```
      (Typing.Let ([((Typing.PVar ((Types.Vid 16), Int)), (Typing.Int 43))],
         (Typing.Let ([((Typing.PVar ((Types.Vid 17), Int)), (Typing.Int 57))],
            (Typing.Let (
               [((Typing.PVar ((Types.Vid 18), Int)),
                 (Typing.App (
                    (Typing.Fun ([((Types.Vid 19), Int)],
                       (Typing.If ((Typing.Bool true), (Typing.Var (Types.Vid 19)),
                          (Typing.Int 100))),
                       Int, "_f_1", ("test.ml", 3, 20, 42))),
                    [(Typing.If ((Typing.Bool true), (Typing.Var (Types.Vid 17)),
                        (Typing.Int 200)))
                      ],
                    Int)))
                 ],
               Typing.Never, true)),
            true)),
         true))
      ```);
      +p{
        `fun`に適用される式は`y`も`200`も`int`なので`int`に推論され、
        それが`int -> int`に適用されるので`f`は`int`に推論される。
      }
      +code(```
      let x = 43
      let f = fun f -> (fun x -> f (f (f x + 10))) 
      ```);
      +code(```
      (Typing.Let ([((Typing.PVar ((Types.Vid 16), Int)), (Typing.Int 43))],
         (Typing.Let (
            [((Typing.PVar ((Types.Vid 17), ((Int -> Int) -> (Int -> Int)))),
              (Typing.Fun ([((Types.Vid 18), (Int -> Int))],
                 (Typing.Fun ([((Types.Vid 19), Int)],
                    (Typing.App ((Typing.Var (Types.Vid 18)),
                       [(Typing.App ((Typing.Var (Types.Vid 18)),
                           [(Typing.App ((Typing.Var (Types.VidTop 0)),
                               [(Typing.App ((Typing.Var (Types.Vid 18)),
                                   [(Typing.Var (Types.Vid 19))], Int));
                                 (Typing.Int 10)],
                               Int))
                             ],
                           Int))
                         ],
                       Int)),
                    Int, "_f_1_2", ("test.ml", 2, 28, 39))),
                 (Int -> Int), "_f_1", ("test.ml", 2, 28, 39))))
              ],
            Typing.Never, true)),
         true))
      ```);
      +p{
        `x`の型は`int`なので`10`との加算が可能。
        よって`f`が最終的に返す型は`int`になる。
        内側の`f`は`x`シャドウイングされているため不明だが、
        返った値が`10`と加算されるため`f`は`? -> int`と分かる。
        また`f x + 10`が`f`に適用されることから`f`は`int -> int`となる。
        ここで`fun f`の内側は`fun x`を受けて`int`を返す。
        このとき`x`は`int -> int`に適用されるので`int`となり、最終的な型は
        `(int -> int) -> int -> int`となる。
        この型は`(int -> int) -> (int -> int)`と同じである（`'a -> 'b -> 'c = a -> ('b -> 'c)`）
      }
      +code(```
      let f = fun f -> (fun g -> fun x -> f (g x))
      ```);
      +code(```
      (Typing.Let ([((Typing.PVar ((Types.Vid 16), Int)), (Typing.Int 42))],
         (Typing.Let (
            [((Typing.PVar ((Types.Vid 17),
                 (('1 -> '0) -> (('2 -> '1) -> ('2 -> '0))))),
              (Typing.Fun ([((Types.Vid 18), ('1 -> '0))],
                 (Typing.Fun ([((Types.Vid 19), ('2 -> '1))],
                    (Typing.Fun ([((Types.Vid 20), '2)],
                       (Typing.App ((Typing.Var (Types.Vid 18)),
                          [(Typing.App ((Typing.Var (Types.Vid 19)),
                              [(Typing.Var (Types.Vid 20))], '1))
                            ],
                          '0)),
                       '0, "_f_1_2_3", ("test.ml", 2, 37, 48))),
                    ('2 -> '0), "_f_1_2", ("test.ml", 2, 37, 48))),
                 (('2 -> '1) -> ('2 -> '0)), "_f_1", ("test.ml", 2, 37, 48))))
              ],
            Typing.Never, true)),
         true))
      ```);
      +p{
        `fun`の引数の`f`は`g x`を取るため、`g`を`? -> 'a`とすると`f`は`'a -> ?`である。
        また`g`は`x`を取るので、`x`を`'b`とすると`g`は`'b -> 'a`となる。
        そうなると全体の式は`('a -> ?) -> ('b -> 'a) -> 'b -> ?`となる。
        最初と最後の`?`は`f`が返す型なので同じ名前で全称量化して`('a -> 'c) -> ('b -> 'a) -> 'c`となり等価になる。
      }
    >
  >
  +subsection {if文の処理} <
    +code(```
    let x = if true then (fun x -> x+1) else (fun y -> y*2)
    ```);
    +code(```
    (Typing.Let (
       [((Typing.PVar ((Types.Vid 16), (Int -> Int))),
         (Typing.If ((Typing.Bool true),
            (Typing.Fun ([((Types.Vid 18), Int)],
               (Typing.App ((Typing.Var (Types.VidTop 0)),
                  [(Typing.Var (Types.Vid 18)); (Typing.Int 1)], Int)),
               Int, "_x_2", ("test.ml", 1, 32, 32))),
            (Typing.Fun ([((Types.Vid 17), Int)],
               (Typing.App ((Typing.Var (Types.VidTop 2)),
                  [(Typing.Var (Types.Vid 17)); (Typing.Int 2)], Int)),
               Int, "_x_1", ("test.ml", 1, 52, 52)))
            )))
         ],
       Typing.Never, true))
    ```);
    +p{
      `x+1`から`x`が`int`であること、`y*2`から`y`が`int`であることが推論され、
      両節の型は`int -> int`となる。
    }
  >
>
