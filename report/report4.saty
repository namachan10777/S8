@import: ./coins.satyh/coins-report

document(|
  author = {中野 将生};
  department = {情報科};
  faculty = {情報};
  id = 2013553;
  title = {関数プログラミング 3-1};
  en = false;
|) '<
  +section ?* ?* ?:((3,1)) {} <
    +subsection ?:(`build-env`) {環境の作成} <
      +p{
        以下のように作成した。
      }
      +code(```
      # let env = emptyenv ();;
      val env : 'a list = []
      # let env = ext env "x" (IntVal 1);;
      val env : (string * value_t) list = [("x", IntVal 1)]
      # let env = ext env "y" (IntVal 2);;
      val env : (string * value_t) list = [("y", IntVal 2); ("x", IntVal 1)]
      # let env = ext env "z" (IntVal 3);;
      val env : (string * value_t) list =
        [("z", IntVal 3); ("y", IntVal 2); ("x", IntVal 1)]
     ```);
   >
   +subsection{yとwの確認} <
     +p{
       `"y"`は登録されていたが、`"w"`はされていなかった。
     }
     +code(```
      # lookup "y" env;;
      - : value_t = IntVal 2
      # lookup "w" env;;
      Exception: Failure "unbound variable: w".
      ```);
    >
    +subsection ?:(`lookup1`) {1つの環境に2つの同じ名前の変数が登録された場合の挙動}<
      +p{
        実際に試したところ以下のようになった。
        `lookup`関数は先頭から順に線形探索を行うので、先頭にあるペアが優先される。
      }
      +code(```
      # let env = emptyenv ();;
      val env : 'a list = []
      # let env = ext env "x" (IntVal 1);;
      val env : (string * value_t) list = [("x", IntVal 1)]
      # let env = ext env "y" (IntVal 2);;
      val env : (string * value_t) list = [("y", IntVal 2); ("x", IntVal 1)]
      # let env = ext env "x" (IntVal 3);;
      val env : (string * value_t) list =
        [("x", IntVal 3); ("y", IntVal 2); ("x", IntVal 1)]
      # lookup "x" env;;
      - : value_t = IntVal 3
      ```);
    >
    +subsection{新しく環境にペアを定義した場合の挙動}<
      +p{
        \ref-sec(`build-env`);での`ext`の挙動から、新しく定義されたペアは先頭に追加されていく。
        また、\ref-sec(`lookup1`);での挙動から見ると環境の先頭から読まれていっているので、
        古い定義のものから順に死んでいく。
      }
    >
  >
  +section{} <
    +subsection{} <
      +code(```
      # eval3 [] (Let("x", IntLit 1, Var "x"));;
      - : value_t = IntVal 1
      # eval3 ["y", IntVal 43; "y", IntVal 34] (Plus (Var "y", Var "y"));;
      - : value_t = IntVal 86
      ```);
    >
    +subsection{} <
      +code(```
      # eval3 [] (Let("x", IntLit 1, Let ("x", IntLit 2, Var "x")));;
      - : value_t = IntVal 2
      # let x = 1 in let x = 2 in x;;
      - : int = 2
      ```);
    >
    +subsection{} <
      +code(```
      # eval3 [] @@ Let ("x", IntLit 1, Let ("y", Plus(Var "x", IntLit 1), Plus(Var "x", Var "y")));;
      []
      []
      [("x", (Kadai3_2.IntVal 1))]
      [("x", (Kadai3_2.IntVal 1))]
      [("x", (Kadai3_2.IntVal 1))]
      [("x", (Kadai3_2.IntVal 1))]
      [("y", (Kadai3_2.IntVal 2)); ("x", (Kadai3_2.IntVal 1))]
      [("y", (Kadai3_2.IntVal 2)); ("x", (Kadai3_2.IntVal 1))]
      [("y", (Kadai3_2.IntVal 2)); ("x", (Kadai3_2.IntVal 1))]
      - : value_t = IntVal 3
      ```);
    >
    +subsection{} <
      +p{
        外側の`let`が評価されると環境に${1}が入った`x`が追加される。
        ここで内側の`let`を評価すると、この環境に${2}を束縛した`x`が追加されるが、
        これは最初の`x`を上書きしない。
        また、OCamlではリストは不変であり、`::`演算子は要素を追加した新しいリストを返すだけである。
        内側の`let`で変数を追加しても外側の環境には影響を及ぼさない。
        最後の式の計算に用いられるのは外側の環境なので、OCamlのリストの特性により、結果として解除が実現できている。
      }
    >
  >
>
