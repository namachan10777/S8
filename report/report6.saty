@import: ./coins.satyh/coins-report
@require: enumitem/enumitem

document(|
  author = {中野 将生};
  department = {情報科};
  faculty = {情報};
  id = 2013553;
  title = {関数プログラミング 5-1};
  en = false;
|) '<
  +section ?* ?* ?:((5,1)) {静的束縛と動的束縛} <
    +subsection{静的束縛} <
      +listing ?:(Enumitem.dot-arabic) {
        * プログラム全体を、空の束縛のもとで実行する
        * `x=10`という束縛を有効にして、2行目以下のプログラムをこの束縛のスコープとする
        * `f = fun y -> x + y`という束縛を有効にして、3行目以下のプログラムをこのスコープとする
        * `f x`を実行する。この時の`x`は`10`なので`f x`は`(fun y -> x + y) 10`となり、`y = 20`に束縛される。
        * `x=20`という束縛を有効にして、5行目以下のプログラムをこの束縛のスコープとする
        * `f (x * y)`を実行する。つまり`(fun f y -> x + y) 400`を実行する。このときの`x`は`20`なので`420`
      }
    >
    +subsection{動的束縛} <
      +listing ?:(Enumitem.dot-arabic) {
        * プログラム全体を、空の束縛のもとで実行する
        * `x=10`という束縛を有効にして、2行目以下のプログラムをこの束縛のスコープとする
        * `f = fun y -> x + y`という束縛を有効にして、3行目以下のプログラムをこのスコープとする
        * `f x`を実行する。この時の`x`は`10`なので`f x`は`(fun y -> x + y) 10`となり、`f`のスコープでの`x`は`10`なので`y = 20`に束縛される。
        * `x=20`という束縛を有効にして、5行目以下のプログラムをこの束縛のスコープとする
        * `f (x * y)`を実行する。つまり`(fun f y -> x + y) 200`を実行する。このとき`f`のスコープでの`x`は`10`なので`410`
      }
    >
  >
  +section {関数の処理とクロージャ} <
    +subsection{eval4の確認} <
      +code(```
        # Kadai5.Top.eval_string "let x = 1 in let f = fun y -> x + y in let x = 2 in f (x + 3)";;
        - : Kadai5.Ast.value_t = Kadai5.Ast.IntVal 6
      ```);
    >
    +subsection{動的束縛への変更}<
      +code(```
        # Kadai5.Top.eval_string "let x = 1 in let f = fun y -> x + y in let x = 2 in f (x + 3)";;
        - : Kadai5.Ast.value_t = Kadai5.Ast.IntVal 7
      ```);
      +p{
        fが適用される時点でfが定義された時点には無かった`x = 2`を用いて計算が行われているので動的束縛と言える。
      }
    >
    +subsection{階乗を求める関数が定義出来るかどうか} <
      +p{
        型無しなので不動点コンビネータを定義することが出来る。評価戦略は`call-by-value`で実装しているのでZコンビネータを用い、
        以下のように計算される。式が長いためテストコードから引用する。
      }
      +code(```
      let test_z _ = 
          let fix = parse_string "fun f -> (fun x -> f (fun y -> x x y)) (fun x -> f (fun y -> x x y))" in
          let fact = parse_string "fun f -> fun n -> if n = 1 then 1 else n * (f (n-1))" in
          let exp = App (App (fix, fact), IntLit 5) in
          assert_equal (eval (emptyenv ()) exp) (IntVal 120)
      ```);
    >
    +subsection{評価順序の確認} <
      +p{
        右の引数を評価してから左の引数を評価するようになっている。
        ここでは見やすさのため`print_endline`を使った。
      }
      +code(```
        # (print_endline "1"; 10) + (print_endline "2"; 20);;
        2
        1
        - : int = 30
        # (print_endline "1"; (fun x -> x))  (print_endline "2"; 20);;
        2
        1
        - : int = 20
      ```);
    >
    +subsection{本実験の処理系での評価順序の確認} <
      +p{
      }
    >
  >
>
